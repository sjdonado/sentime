import os
import json

import twint
import asyncio

from queue import Queue
from threading import Thread

from datetime import date
from datetime import timedelta

from flask import session, Blueprint

from .. import socketio, app

num_workers = 5
num_days = 1
cities_path = os.path.join(app.static_folder, 'data', 'colombia_departments_capitals_locations.json')

with open(cities_path) as f:
  cities = json.load(f)

# Blueprint Configuration
search_bp = Blueprint('search_bp', __name__,
                      template_folder='templates',
                      static_folder='static')

async def worker(text, queue):
  while True:
    # Get a "work item" out of the queue.
    city = await queue.get()
    print("city: {}, text: {}".format(city['formatted_address'], text), flush=True)
    c = twint.Config()
    c.Search = text
    c.Limit = 1
    c.Since = (date.today() - timedelta(days=num_days)).strftime('%Y-%m-%d')
    c.Filter_retweets = True
    c.Store_object = True
    c.Location = True
    c.Hide_output = True
    c.Show_hashtags = False
    # TODO: Fit radio based on city boundaries
    c.Geo = "{},{},5km".format(
      city['geometry']['location']['lat'],
      city['geometry']['location']['lng']
    )
    def callback():
      tweets = [t.__dict__ for t in twint.output.tweets_list]
      socketio.emit('tweets', {
        'status': 'processing',
        'data': {
          'city': city,
          'tweets': tweets
        }
      })
      # Notify the queue that the "work item" has been processed.
      queue.task_done()

    twint.run.Search(c, callback=callback)

async def main(text):
  queue = asyncio.Queue()

  for city in cities:
    queue.put_nowait(city)

  # Create three worker tasks to process the queue concurrently.
  tasks = []
  for _ in range(num_workers):
    loop = asyncio.get_event_loop()
    task = loop.create_task(worker(text, queue))
    tasks.append(task)

  # Wait until the queue is fully processed.
  await queue.join()

  # Cancel our worker tasks.
  for task in tasks:
    task.cancel()
  # Wait until all worker tasks are cancelled.
  await asyncio.gather(*tasks, return_exceptions=True)

@socketio.on('search')
def search(message):
  data = json.loads(message)
  text = data['text']
  session['text'] = text

  socketio.emit('tweets', { 'status': 'started' })

  loop = asyncio.new_event_loop()
  asyncio.set_event_loop(loop)
  loop.run_until_complete(main(text))

  socketio.emit('tweets', { 'status': 'finished' })
